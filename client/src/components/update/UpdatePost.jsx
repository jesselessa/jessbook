import { useState, useRef } from "react";
import "./updatePost.scss";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { makeRequest } from "../../utils/axios.js";
import { uploadFile } from "../../utils/uploadFile.js";
import { useCleanUpFileURL } from "../../hooks/useCleanUpFileURL.js";
import { toast } from "react-toastify";

// Components
import LazyLoadImage from "../../components/lazyLoadImage/LazyLoadImage.jsx";
import Loader from "../../components/loader/Loader.jsx";

// Icon
import CloudUploadIcon from "@mui/icons-material/CloudUpload";

export default function UpdatePost({ post, setOpenUpdate, userId }) {
  const [newText, setNewText] = useState(post.text);
  const [newImg, setNewImg] = useState(null);
  const fileInputRef = useRef(null);

  const queryClient = useQueryClient();

  // Generate a temporary   preview URL for selected file and clean up memory automatically
  const newImgUrl = useCleanUpFileURL(newImg);

  // Mutation to handle optimistic update for post
  const updateMutation = useMutation({
    mutationFn: (updatedPost) =>
      makeRequest.put(`/posts/${post.id}`, updatedPost),

    // OnMutate → Before the request happens
    onMutate: async (updatedPost) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries(["posts", userId]);

      // Store current state
      const previousPosts = queryClient.getQueryData(["posts", userId]);

      // Optimistically update cache
      //! ⚠️ Reminder: Don't merge an uncomplete optimistic object (e.g., if we only return 'text' and 'img', whereas 'posts' SQL table also contains other keys), in this case 'updatedPost', because it will overwrite our existing data => 💡 Only merge with the new one !!!
      queryClient.setQueryData(["posts", userId], (oldPosts = []) => {
        return oldPosts.map((p) =>
          p.id === post.id
            ? { ...p, text: updatedPost.text, img: updatedPost.img || p.img }
            : p
        );
      });

      // Context for rollback
      return { previousPosts };
    },

    // OnError → Rollback to previous state
    onError: (err, _updatedPost, context) => {
      console.error("Error updating post:", err);
      toast.error(
        "Error updating post: " + (err.response?.data?.message || err.message)
      );

      if (context?.previousPosts) {
        queryClient.setQueryData(["posts", userId], context.previousPosts);
      }
    },

    // OnSuccess → Successful mutation
    onSuccess: () => {
      toast.success("Post updated.");
    },

    // OnSettled → Either mutation succeeds or fails
    onSettled: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries(["posts", userId]);

      // Reset states
      setOpenUpdate(false); // Close form
      setNewImg(null); // Cleanup local state

      // Reset input value in DOM
      if (fileInputRef.current) fileInputRef.current.value = "";
    },
  });

  const isUpdating = updateMutation.isPending;

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Prevent multiple submissions
    if (isUpdating) return;

    // Check if post has been modified
    const trimmedText = newText?.trim();
    const hasTextChanged = trimmedText !== post.text?.trim();
    const hasImageChanged = newImg !== null;

    if (!hasTextChanged && !hasImageChanged) {
      toast.info("No changes detected.");
      return;
    }

    // Check if description is empty
    if (!trimmedText) {
      toast.error("You must add a description to your post.");
      return;
    }

    // Check post length
    if (trimmedText.length > 1000) {
      toast.error("Your post can't contain more than 1000\u00A0characters.");
      return;
    }

    // Prepare updated post object
    const updatedPost = {
      ...post,
      text: newText.trim(),
    };

    // Upload new image if selected
    if (hasImageChanged) {
      try {
        updatedPost.img = await uploadFile(newImg);
      } catch (err) {
        console.error("Error uploading image:", err);
        toast.error(
          "Error uploading image: " + (err.message || "Try again later.")
        );
        return; // Stop if image upload fails
      }
    }

    // Trigger mutation
    updateMutation.mutate(updatedPost);
  };

  return (
    <>
      <div className="updatePost">
        <div className="wrapper">
          <h1>Update Your Post</h1>

          <form name="update-post-form" onSubmit={handleSubmit}>
            <div className="files">
              <div className="image">
                <span>Choose an image</span>
                <div className="img-container">
                  {(newImgUrl || post.img) && (
                    <LazyLoadImage
                      src={
                        newImgUrl
                          ? // URL generated by the hook
                            newImgUrl
                          : `/uploads/${post.img}` // Existing image
                      }
                      alt="post preview"
                    />
                  )}

                  {/* File input for image selection */}
                  <label className="file-label" htmlFor="new-file">
                    <CloudUploadIcon className="icon" />
                  </label>
                  <input
                    type="file"
                    //! 'id' must be different from input in Publish to prevent conflicts when displaying image
                    id="new-file"
                    name="new-file"
                    accept="image/*"
                    onChange={(e) => setNewImg(e.target.files[0])}
                    disabled={isUpdating}
                    ref={fileInputRef}
                  />
                </div>
              </div>
            </div>

            <label htmlFor="new-text">Add a new text</label>
            <textarea
              id="new-text"
              name="new-text"
              rows={8}
              placeholder="Write a text..."
              value={newText}
              onChange={(e) => setNewText(e.target.value)}
              disabled={isUpdating}
            />

            <button type="submit" className="submit" disabled={isUpdating}>
              {isUpdating ? (
                <Loader
                  width="24px"
                  height="24px"
                  border="3px solid rgba(0, 0, 0, 0.1)"
                />
              ) : (
                "Update"
              )}
            </button>
          </form>

          <button
            className="close"
            onClick={() => setOpenUpdate(false)}
            disabled={isUpdating}
          >
            X
          </button>
        </div>
      </div>
    </>
  );
}
