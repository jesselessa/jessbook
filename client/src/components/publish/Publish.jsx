import { useContext, useState, useRef } from "react";
import "./publish.scss";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { makeRequest } from "../../utils/axios.js";
import { uploadFile } from "../../utils/uploadFile.js";
import { useCleanUpFileURL } from "../../hooks/useCleanUpFileURL.js";
import { toast } from "react-toastify";

// Components
import SendOutlinedIcon from "@mui/icons-material/SendOutlined";
import LazyLoadImage from "../lazyLoadImage/LazyLoadImage.jsx";
import Loader from "../loader/Loader.jsx";

// Images
import defaultProfile from "../../assets/images/users/defaultProfile.jpg";
import picture from "../../assets/images/publish/image.png";
import map from "../../assets/images/publish/map.png";
import friends from "../../assets/images/publish/friends.png";

// Contexts
import { AuthContext } from "../../contexts/authContext.jsx";
import { DarkModeContext } from "../../contexts/darkModeContext.jsx";

export default function Publish() {
  const { currentUser } = useContext(AuthContext);
  const { darkMode } = useContext(DarkModeContext);
  const fileInputRef = useRef(null);

  const [text, setText] = useState("");
  const [image, setImage] = useState(null); // Image selected or not
  const [error, setError] = useState({ isError: false, message: "" });

  const queryClient = useQueryClient();

  // Mutation to create a new post (with optimistic update)
  const mutation = useMutation({
    mutationFn: (newPost) => makeRequest.post("/posts", newPost),

    // OnMutate, immediately update the cache before the server response
    onMutate: async (newPost) => {
      await queryClient.cancelQueries(["posts", currentUser.id]); // Cancel any outgoing fetches for posts to prevent conflicts

      // Snapshot the previous post data to revert if mutation fails
      const previousPosts = queryClient.getQueryData(["posts", currentUser.id]); // Store the current state

      // Create an optimistic post
      //! Note: The optimistic object doesn't have to be identical to the SQL table â†’ It just needs to be complete enough for our UI to display the correct state while waiting for the server response
      //! When the server responds, Tanstack Query reconciles the real data with the cache
      const currentDate = new Date().toISOString();

      const optimisticPost = {
        id: crypto.randomUUID(), // Temporary ID (could create a slight flicker - not a bug - but it's without consequences)
        userId: currentUser.id,
        text: newPost.text,
        img: newPost.img || null,
        createdAt: currentDate,
      };

      // Optimistically update the post in cache
      queryClient.setQueryData(["posts", currentUser.id], (oldPost) => [
        ...(oldPost || []),
        optimisticPost,
      ]);

      // Return context with previous data for rollback in case of error
      return { previousPosts };
    },

    // If the mutation fails, rollback the optimistic update
    onError: (error, _newPost, context) => {
      console.error("Error creating post:", error);
      toast.error(
        "Error creating post: " +
          (error.response?.data?.message || error.message)
      );

      // Rollback on error
      if (context?.previousPosts) {
        queryClient.setQueryData(
          ["posts", currentUser.id],
          context.previousPosts
        );
      }
    },

    // If the mutation is successful, display a message
    onSuccess: () => {
      toast.success("Post created.");
    },

    // Either the mutation succeeds or fails, refresh data and reset states
    onSettled: () => {
      // Invalidate queries to refetch fresh data
      queryClient.invalidateQueries(["posts", currentUser.id]);
      // Note: No need to do it for comments and likes because they depend on postId (and not on post content)

      // Reset states
      setImage(null); // Make sure URL generated by URL.createObjectURL is no longer used
      setText("");

      // Reset input value in DOM
      if (fileInputRef.current) fileInputRef.current.value = "";
    },
  });

  // Access the publication state using 'isPending' property from useMutation
  const isPublishing = mutation.isPending;

  const handleSubmit = async (e) => {
    e.preventDefault();

    const trimmedText = text.trim();

    // Check post length
    if (trimmedText.length === 0) {
      setError({
        isError: true,
        message: "Your post must contain a description.",
      });

      setTimeout(() => {
        setError({ isError: false, message: "" });
      }, 3000);

      return;
    }

    if (trimmedText.length > 1000) {
      setError({
        isError: true,
        message: "Your post can't contain more than 1000\u00A0characters.",
      });

      setTimeout(() => {
        setError({ isError: false, message: "" });
      }, 3000);

      return;
    }

    // Upload new image if present
    const newImage = image && (await uploadFile(image));

    // Trigger mutation to update database
    mutation.mutate({
      text: trimmedText,
      img: newImage,
    });
  };

  // Release URL resource to prevent memory leaks
  const imagePreviewUrl = useCleanUpFileURL(image);

  return (
    <div className="publish">
      <div className="top">
        <div className="left">
          {/* User's profile picture */}
          <div className="img-container">
            <LazyLoadImage
              src={
                // Image uploaded on server or default picture
                currentUser?.profilePic
                  ? `/uploads/${currentUser.profilePic}`
                  : defaultProfile
              }
              alt="user"
            />
          </div>

          <div className="input-group">
            <input
              type="text"
              name="text"
              placeholder={`What's up, ${currentUser?.firstName}\u00A0?`}
              value={text}
              onChange={(e) => setText(e.target.value)}
              autoComplete="off"
              disabled={isPublishing}
            />

            {isPublishing ? (
              <Loader
                width="24px"
                height="24px"
                border="3px solid rgba(0, 0, 0, 0.1)"
              />
            ) : (
              <SendOutlinedIcon
                className={darkMode ? "send dark" : "send"}
                sx={{
                  fontSize: "24px",
                  color: darkMode ? "lightgray" : "#555",
                }}
                onClick={handleSubmit}
              />
            )}
          </div>
        </div>

        <div className="right">
          {/* Image preview */}
          {imagePreviewUrl && (
            <div className="img-container">
              <LazyLoadImage
                src={imagePreviewUrl}
                // Generate a dynamic URL for preview
                alt="post preview"
              />

              <button
                className="close"
                onClick={() => setImage(null)}
                disabled={isPublishing}
              >
                x
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Error message */}
      {error.isError && <span className="error-msg">{error.message}</span>}

      <hr />

      <div className="bottom">
        <div className="left">
          {/* Add a new image */}
          <label className="file-label-mob" htmlFor="file">
            <LazyLoadImage src={picture} alt="image icon" />
          </label>

          {/* Note: The input:file value linked with state doesn't work, except if it equals "" or "null" */}
          <input
            type="file"
            id="file"
            name="file"
            accept="image/*"
            onChange={(e) => setImage(e.target.files[0])}
            disabled={isPublishing}
            ref={fileInputRef}
          />

          <div className="add-img">
            <LazyLoadImage src={picture} alt="image icon" />
            <label className="file-label" htmlFor="file">
              <span>Add Image</span>
            </label>
          </div>

          <div className="item">
            <LazyLoadImage src={map} alt="map icon" />
            <span>Add Place</span>
          </div>

          <div className="item">
            <LazyLoadImage src={friends} alt="friends icon" />
            <span>Tag Friends</span>
          </div>
        </div>

        <div className="right">
          <button type="submit" onClick={handleSubmit} disabled={isPublishing}>
            {isPublishing ? (
              <Loader
                width="20px"
                height="20px"
                border="2px solid rgba(0, 0, 0, 0.1)"
              />
            ) : (
              "Publish"
            )}
          </button>
        </div>
      </div>
    </div>
  );
}
